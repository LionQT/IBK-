# -*- coding: utf-8 -*-
"""í‡´ì§ìœ¨0624.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1CGaiz-qNrnBDMYw_v1_HUl8lfOKcUl4B
"""

#ë°ì´í„° ì—°ê²°

from google.colab import drive
drive.mount('/content/drive')

path_resigned = '/content/drive/MyDrive/Colab Notebooks/IBK/í‡´ì‚¬ì.csv'
path_employed = '/content/drive/MyDrive/Colab Notebooks/IBK/ì¬ì§ì.csv'

import pandas as pd

df_resigned_raw = pd.read_csv(path_resigned, encoding='cp949')
df_employed_raw = pd.read_csv(path_employed, encoding='cp949')

#ì •ë³´ ì¶”ì¶œ
def extract_birth_gender(rrn):
    try:
        birth_year = int(rrn[:2])
        code = rrn[7]
        century = 1900 if code in ['1', '2'] else 2000
        year = century + birth_year
        gender = 1 if code in ['1', '3'] else 0
        return year, gender
    except:
        return None, None

def preprocess_resigned(df):
    today = pd.to_datetime('today')
    df = df.drop(columns=['êµ¬ë¶„', 'NO.'], errors='ignore')
    df['ì…ì‚¬ì¼'] = pd.to_datetime(df['ì…ì‚¬ì¼'], errors='coerce')
    df['í‡´ì‚¬ì¼'] = pd.to_datetime(df['í‡´ì‚¬ì¼'], errors='coerce')
    df['ìƒë…„'], df['ì„±ë³„'] = zip(*df['ì£¼ë¯¼ë“±ë¡ë²ˆí˜¸'].astype(str).map(extract_birth_gender))
    df['ë‚˜ì´'] = today.year - df['ìƒë…„']
    df['ì¬ì§ê°œì›”'] = ((df['í‡´ì‚¬ì¼'].fillna(today)) - df['ì…ì‚¬ì¼']).dt.days // 30
    df['í‡´ì‚¬ì—¬ë¶€'] = 1
    return df

def preprocess_employed(df):
    today = pd.to_datetime('today')
    df = df.rename(columns={
        'ì„±ëª…': 'ì´ë¦„',
        'ì…ì‚¬ì¼ì': 'ì…ì‚¬ì¼'
    })
    df['ì…ì‚¬ì¼'] = pd.to_datetime(df['ì…ì‚¬ì¼'], errors='coerce')
    df['ìƒë…„'], df['ì„±ë³„'] = zip(*df['ì£¼ë¯¼ë“±ë¡ë²ˆí˜¸'].astype(str).map(extract_birth_gender))
    df['ë‚˜ì´'] = today.year - df['ìƒë…„']
    df['ì¬ì§ê°œì›”'] = (today - df['ì…ì‚¬ì¼']).dt.days // 30
    df['í‡´ì‚¬ì—¬ë¶€'] = 0
    df['í‡´ì‚¬ì¼'] = pd.NaT  # ì¬ì§ìëŠ” í‡´ì‚¬ì¼ None ì¶”ê°€
    return df

df_resigned = preprocess_resigned(df_resigned_raw)
df_employed = preprocess_employed(df_employed_raw)
df_all = pd.concat([df_resigned, df_employed], ignore_index=True)

from sklearn.preprocessing import LabelEncoder

#NaN ì²˜ë¦¬
df_all['ì§ë¬´'] = df_all['ì§ë¬´'].fillna('ë¯¸ì§€ì •')
df_all['ê·¼ë¬´ì§€'] = df_all['ê·¼ë¬´ì§€'].fillna('ë¯¸ì§€ì •')
df_all['í•™ë ¥'] = df_all['í•™ë ¥'].fillna('ë¯¸ì§€ì •')

le_job = LabelEncoder()
le_loc = LabelEncoder()
le_edu = LabelEncoder()
le_job.fit(df_all['ì§ë¬´'].astype(str))
le_loc.fit(df_all['ê·¼ë¬´ì§€'].astype(str))
le_edu.fit(df_all['í•™ë ¥'].astype(str))

df_resigned['ì§ë¬´_encoded'] = le_job.transform(df_resigned['ì§ë¬´'].astype(str))
df_resigned['ê·¼ë¬´ì§€_encoded'] = le_loc.transform(df_resigned['ê·¼ë¬´ì§€'].astype(str))
df_resigned['í•™ë ¥_encoded'] = le_edu.transform(df_resigned['í•™ë ¥'].astype(str))
df_employed['ì§ë¬´_encoded'] = le_job.transform(df_employed['ì§ë¬´'].astype(str))
df_employed['ê·¼ë¬´ì§€_encoded'] = le_loc.transform(df_employed['ê·¼ë¬´ì§€'].astype(str))
df_employed['í•™ë ¥_encoded'] = le_edu.transform(df_employed['í•™ë ¥'].astype(str))

df_resigned['ì§ë¬´_í…ìŠ¤íŠ¸'] = le_job.inverse_transform(df_resigned['ì§ë¬´_encoded'])
df_resigned['ê·¼ë¬´ì§€_í…ìŠ¤íŠ¸'] = le_loc.inverse_transform(df_resigned['ê·¼ë¬´ì§€_encoded'])
df_employed['ì§ë¬´_í…ìŠ¤íŠ¸'] = le_job.inverse_transform(df_employed['ì§ë¬´_encoded'])
df_employed['ê·¼ë¬´ì§€_í…ìŠ¤íŠ¸'] = le_loc.inverse_transform(df_employed['ê·¼ë¬´ì§€_encoded'])

#ë°ì´í„° ì •ë¦¬
df_all.drop(columns=['êµ¬ë¶„', 'NO.'], inplace=True, errors='ignore')
df_all = df_all.loc[:, ~df_all.columns.str.startswith('Unnamed')]

df_all['ì…ì‚¬ì¼'] = pd.to_datetime(df_all['ì…ì‚¬ì¼'], errors='coerce')
df_all['í‡´ì‚¬ì¼'] = pd.to_datetime(df_all['í‡´ì‚¬ì¼'], errors='coerce')

df_all['ë“±ê¸‰'] = df_all['ë“±ê¸‰'].astype('Int64')
df_all['ë‹¨ê³„'] = df_all['ë‹¨ê³„'].astype('Int64')

df_all = df_all.dropna(subset=['ì„±ë³„', 'ë‚˜ì´', 'ì¬ì§ê°œì›”', 'ì§ë¬´', 'ê·¼ë¬´ì§€'])

df_all = df_all[df_all['ì¬ì§ê°œì›”'] >= 0]

print(df_all.isnull().sum())

df_all.head(20)

#í•œê¸€ í…ìŠ¤íŠ¸ íŒ¨ì¹˜
!sudo apt-get install -y fonts-nanum
!sudo fc-cache -fv
!rm ~/.cache/matplotlib -rf

#í•œê¸€ íŒ¨ì¹˜ í™•ì¸
import matplotlib.pyplot as plt
plt.rc('font', family='NanumBarunGothic')

#ê·¼ë¬´ì§€ë³„ í‡´ì‚¬ì ìˆ˜
loc_counts = df_resigned['ê·¼ë¬´ì§€_í…ìŠ¤íŠ¸'].value_counts()
print('ê·¼ë¬´ì§€ë³„ í‡´ì‚¬ì ìˆ˜:')
print(loc_counts, '\n')

import pandas as pd
import matplotlib.pyplot as plt

#ê·¼ë¬´ì§€ë³„ + ì§ë¬´ë³„ í‡´ì‚¬ì ìˆ˜ ì§‘ê³„
pivot_table = df_resigned.pivot_table(
    index='ê·¼ë¬´ì§€_í…ìŠ¤íŠ¸',
    columns='ì§ë¬´_í…ìŠ¤íŠ¸',
    values='ì´ë¦„',  # ì´ë¦„ì„ ì¹´ìš´íŠ¸
    aggfunc='count',
    fill_value=0
)

top_40_locations = pivot_table.sum(axis=1).sort_values(ascending=False).head(30).index
pivot_top40 = pivot_table.loc[top_40_locations]

pivot_top40.plot(kind='bar', stacked=True, figsize=(14, 7))
plt.title('ê·¼ë¬´ì§€ë³„ ì§ë¬´ë³„ í‡´ì‚¬ì ìˆ˜ (ìƒìœ„ 30 ê·¼ë¬´ì§€)')
plt.ylabel('í‡´ì‚¬ì ìˆ˜')
plt.xlabel('ê·¼ë¬´ì§€')
plt.xticks(rotation=60)
plt.legend(title='ì§ë¬´', bbox_to_anchor=(1.05, 1), loc='upper left')
plt.tight_layout()
plt.show()

import pandas as pd
from sklearn.preprocessing import LabelEncoder
from sklearn.ensemble import RandomForestClassifier

#ë³‘í•©
df_resigned = preprocess_resigned(df_resigned_raw)
df_employed = preprocess_employed(df_employed_raw)

#ê¸°ë³¸ê°’ ì±„ìš°ê¸°
for df in [df_resigned, df_employed]:
    if 'ë“±ê¸‰' not in df.columns:
        df['ë“±ê¸‰'] = 1
    if 'ë‹¨ê³„' not in df.columns:
        df['ë‹¨ê³„'] = 1
    if 'í•™ë ¥' not in df.columns:
        df['í•™ë ¥'] = 'ë¯¸ì§€ì •'

df_resigned['í‡´ì‚¬ì—¬ë¶€'] = 1
df_employed['í‡´ì‚¬ì—¬ë¶€'] = 0
df_all = pd.concat([df_resigned, df_employed], ignore_index=True)

le_job = LabelEncoder()
le_loc = LabelEncoder()
le_edu = LabelEncoder()
le_job.fit(df_all['ì§ë¬´'].astype(str))
le_loc.fit(df_all['ê·¼ë¬´ì§€'].astype(str))
le_edu.fit(df_all['í•™ë ¥'].astype(str))

df_all['ì§ë¬´_encoded'] = le_job.transform(df_all['ì§ë¬´'].astype(str))
df_all['ê·¼ë¬´ì§€_encoded'] = le_loc.transform(df_all['ê·¼ë¬´ì§€'].astype(str))
df_all['í•™ë ¥_encoded'] = le_edu.transform(df_all['í•™ë ¥'].astype(str))

#í•™ìŠµìš© ë°ì´í„°
features = ['ë‚˜ì´', 'ì¬ì§ê°œì›”', 'ì„±ë³„', 'ì§ë¬´_encoded', 'ê·¼ë¬´ì§€_encoded', 'í•™ë ¥_encoded', 'ë“±ê¸‰', 'ë‹¨ê³„']
X = df_all[features]
y = df_all['í‡´ì‚¬ì—¬ë¶€']

#ëœë¤í¬ë ˆìŠ¤íŠ¸
model = RandomForestClassifier(class_weight='balanced', random_state=42)
model.fit(X, y)

#ì¬ì§ì í‡´ì‚¬í™•ë¥  ì˜ˆì¸¡
df_employed['ì§ë¬´_encoded'] = le_job.transform(df_employed['ì§ë¬´'].astype(str))
df_employed['ê·¼ë¬´ì§€_encoded'] = le_loc.transform(df_employed['ê·¼ë¬´ì§€'].astype(str))
df_employed['í•™ë ¥_encoded'] = le_edu.transform(df_employed['í•™ë ¥'].astype(str))
X_predict = df_employed[features]
df_employed['í‡´ì‚¬í™•ë¥ '] = model.predict_proba(X_predict)[:, 1]
df_employed['í‡´ì‚¬í™•ë¥ (%)'] = (df_employed['í‡´ì‚¬í™•ë¥ '] * 100).round(1).astype(str) + '%'

df_employed_sorted = df_employed.sort_values(by='í‡´ì‚¬í™•ë¥ ', ascending=False)

#ê²°ê³¼
result_columns = ['ì´ë¦„', 'ë‚˜ì´', 'ì§ë¬´', 'ê·¼ë¬´ì§€', 'í•™ë ¥', 'ì…ì‚¬ì¼', 'ì¬ì§ê°œì›”', 'í‡´ì‚¬í™•ë¥ (%)']
print(df_employed_sorted[result_columns].head(50))



#XGBoost
import pandas as pd
from sklearn.preprocessing import LabelEncoder
import xgboost as xgb
from sklearn.metrics import accuracy_score, classification_report
from sklearn.model_selection import train_test_split, cross_val_score
import matplotlib.pyplot as plt

def preprocess_resigned(df):
    today = pd.to_datetime('today')
    df['ì…ì‚¬ì¼'] = pd.to_datetime(df['ì…ì‚¬ì¼'], errors='coerce')
    df['í‡´ì‚¬ì¼'] = pd.to_datetime(df['í‡´ì‚¬ì¼'], errors='coerce')
    df['ìƒë…„'], df['ì„±ë³„'] = zip(*df['ì£¼ë¯¼ë“±ë¡ë²ˆí˜¸'].astype(str).map(extract_birth_gender))
    df['ë‚˜ì´'] = today.year - df['ìƒë…„']
    df['ì¬ì§ê°œì›”'] = ((df['í‡´ì‚¬ì¼'].fillna(today)) - df['ì…ì‚¬ì¼']).dt.days // 30
    df['í‡´ì‚¬ì—¬ë¶€'] = 1
    return df

def preprocess_employed(df):
    today = pd.to_datetime('today')
    df.rename(columns={'ì…ì‚¬ì¼ì': 'ì…ì‚¬ì¼'}, inplace=True)
    df['ì…ì‚¬ì¼'] = pd.to_datetime(df['ì…ì‚¬ì¼'], errors='coerce')
    df['ìƒë…„'], df['ì„±ë³„'] = zip(*df['ì£¼ë¯¼ë“±ë¡ë²ˆí˜¸'].astype(str).map(extract_birth_gender))
    df['ë‚˜ì´'] = today.year - df['ìƒë…„']
    df['ì¬ì§ê°œì›”'] = (today - df['ì…ì‚¬ì¼']).dt.days // 30
    df['í‡´ì‚¬ì—¬ë¶€'] = 0
    df['í‡´ì‚¬ì¼'] = pd.NaT
    return df

#ì¶”ì¶œ
def extract_birth_gender(rrn):
    try:
        birth_year = int(rrn[:2])
        code = rrn[7]
        century = 1900 if code in ['1', '2'] else 2000
        year = century + birth_year
        gender = 1 if code in ['1', '3'] else 0
        return year, gender
    except:
        return None, None

#ë³‘í•©
df_resigned = preprocess_resigned(df_resigned_raw)
df_employed = preprocess_employed(df_employed_raw)
for df in [df_resigned, df_employed]:
    df['ë“±ê¸‰'] = df.get('ë“±ê¸‰', 1)
    df['ë‹¨ê³„'] = df.get('ë‹¨ê³„', 1)
    df['í•™ë ¥'] = df.get('í•™ë ¥', 'ë¯¸ì§€ì •')

df_resigned['í‡´ì‚¬ì—¬ë¶€'] = 1
df_employed['í‡´ì‚¬ì—¬ë¶€'] = 0
df_all = pd.concat([df_resigned, df_employed], ignore_index=True)

le_job, le_loc, le_edu = LabelEncoder(), LabelEncoder(), LabelEncoder()
le_job.fit(df_all['ì§ë¬´'].astype(str))
le_loc.fit(df_all['ê·¼ë¬´ì§€'].astype(str))
le_edu.fit(df_all['í•™ë ¥'].astype(str))

df_all['ì§ë¬´_encoded'] = le_job.transform(df_all['ì§ë¬´'].astype(str))
df_all['ê·¼ë¬´ì§€_encoded'] = le_loc.transform(df_all['ê·¼ë¬´ì§€'].astype(str))
df_all['í•™ë ¥_encoded'] = le_edu.transform(df_all['í•™ë ¥'].astype(str))

#í•™ìŠµìš© ë°ì´í„°
features = ['ë‚˜ì´', 'ì¬ì§ê°œì›”', 'ì„±ë³„', 'ì§ë¬´_encoded', 'ê·¼ë¬´ì§€_encoded', 'í•™ë ¥_encoded', 'ë“±ê¸‰', 'ë‹¨ê³„']
X = df_all[features]
y = df_all['í‡´ì‚¬ì—¬ë¶€']

#train/test ë¶„ë¦¬
X_train, X_val, y_train, y_val = train_test_split(X, y, test_size=0.2, random_state=42, stratify=y)

#ëª¨ë¸ í•™ìŠµ
model = xgb.XGBClassifier(n_estimators=300, learning_rate=0.1, max_depth=5, random_state=42, eval_metric='logloss')
model.fit(X_train, y_train)

#ë°ì´í„° ê²€ì¦
y_pred_val = model.predict(X_val)
acc_val = accuracy_score(y_val, y_pred_val)
print(f"\nâœ… ê²€ì¦ ë°ì´í„° ì •í™•ë„: {acc_val:.4f}")
print("\nâœ… ê²€ì¦ ë°ì´í„° ë¶„ë¥˜ ë¦¬í¬íŠ¸:")
print(classification_report(y_val, y_pred_val))

#êµì°¨ ê²€ì¦
cv_scores = cross_val_score(model, X, y, cv=5, scoring='accuracy')
print(f"\nâœ… êµì°¨ ê²€ì¦ ì •í™•ë„ í‰ê· : {cv_scores.mean():.4f}")
print(f"âœ… foldë³„ ì •í™•ë„: {cv_scores}")

#ì „ì²´ ë°ì´í„°ë¡œ ìµœì¢… í•™ìŠµ
model.fit(X, y)

#feature ì¤‘ìš”ë„ ì‹œê°í™”
xgb.plot_importance(model, max_num_features=10, importance_type='gain')
plt.title('ğŸš€ XGBoost Feature Importance')
plt.show()

#ì¬ì§ì ì˜ˆì¸¡
df_employed['ì§ë¬´_encoded'] = le_job.transform(df_employed['ì§ë¬´'].astype(str))
df_employed['ê·¼ë¬´ì§€_encoded'] = le_loc.transform(df_employed['ê·¼ë¬´ì§€'].astype(str))
df_employed['í•™ë ¥_encoded'] = le_edu.transform(df_employed['í•™ë ¥'].astype(str))
X_predict = df_employed[features]
df_employed['í‡´ì‚¬í™•ë¥ '] = model.predict_proba(X_predict)[:, 1]
df_employed['í‡´ì‚¬í™•ë¥ (%)'] = (df_employed['í‡´ì‚¬í™•ë¥ '] * 100).round(1).astype(str) + '%'

df_employed_sorted = df_employed.sort_values(by='í‡´ì‚¬í™•ë¥ ', ascending=False)

#ê²°ê³¼
result_columns = ['ì´ë¦„', 'ë‚˜ì´', 'ì§ë¬´', 'ê·¼ë¬´ì§€', 'í•™ë ¥', 'ì…ì‚¬ì¼', 'ì¬ì§ê°œì›”', 'í‡´ì‚¬í™•ë¥ (%)']
print(df_employed_sorted[result_columns].head(50))


output_path = '/content/drive/MyDrive/Colab Notebooks/IBK/í‡´ì‚¬ì˜ˆì¸¡ê²°ê³¼.xlsx'
df_employed_sorted[result_columns].to_excel(output_path, index=False)













